# =============================================================================
# Workload for a Hierarchical CNN Accelerator Simulation (Final Version)
# =============================================================================
#
# 行为模型:
# 1. `delta_events` 定义了所有“自上而下”(DRAM->GLB, GLB->PEs)的主动数据推送。
#    它们是系统的“发动机”。
# 2. `command_definitions` 是一份“行为菜单”，供 PE 在完成计算后查阅。
#    `evict_payload` 字段同时定义了“回送多少Output数据”和“驱逐多少数据”。
#
# =============================================================================
topology: "HIERARCHICAL"

hierarchical_config:
  num_levels: 4
  connection_mode: "tree"
  word_bits: 8
  
  level_configs:
    # Level 0: DRAM (系统内存)
    - level: 0
      node_type: "DRAM"
      buffer_size: 37748736
      roles: "ROLE_DRAM"
      bandwidth: 512
      fanouts: 1
      routing_patterns:  
        INPUT:  
          mode: "INPUT"  
          port_groups: [[1]] 
        WEIGHT:  
          mode: "WEIGHT"  
          port_groups: [[1]]  
        OUTPUT:  
          mode: "OUTPUT"  
          port_groups: [[1]]  

    # Level 1: GLB (对应 8x12 中的 "8" 这一维)
    # 假设该维度为标准的单播分发（因为日志只显示了12那一维的复杂多播）
    - level: 1
      node_type: "GLB"
      buffer_size: 16384
      roles: "ROLE_GLB"
      bandwidth: 512
      fanouts: 8
      aggregate: true
      routing_patterns:  
        INPUT:  
          port_groups: [[0,1,2,3,4,5,6,7]]
        WEIGHT:  
          port_groups: [[0], [1], [2], [3], [4], [5], [6], [7]]
        OUTPUT:  
          port_groups: [[0], [1], [2], [3], [4], [5], [6], [7]]

    # Level 2: DISTRIBUTOR (对应 8x12 中的 "12" 这一维 - 日志来源层)
    - level: 2
      node_type: "DISTRIBUTOR"
      buffer_size: 0 # 维持您提供的buffer配置
      roles: "ROLE_BUFFER"
      bandwidth: 128
      fanouts: 12
      routing_patterns:  
        
        # pv=0 (WEIGHT): 日志中无多播记录 -> 单播
        # 每个数据包只发送给唯一的 PE
        WEIGHT:  
          port_groups: [
            [0], [1], [2], [3], [4], [5], 
            [6], [7], [8], [9], [10], [11]
          ]
          
        # pv=1 (INPUT): 日志显示 num_matches=4, 且索引跨度为3 (如0,3,6,9) -> 交错多播
        # 数据被多播到间隔为3的4个PE上
        INPUT:  
          port_groups: [
            [0, 3, 6, 9], 
            [1, 4, 7, 10], 
            [2, 5, 8, 11]
          ]
            
        # pv=2 (OUTPUT): 日志显示 num_matches=3, 且索引连续 (如0,1,2) -> 块状多播
        # 数据被多播/收集自连续的3个PE
        OUTPUT:  
          port_groups: [
            [0, 1, 2], 
            [3, 4, 5], 
            [6, 7, 8], 
            [9, 10, 11]
          ]
      
    # Level 3: COMPUTE (PE)
    - level: 3
      node_type: "COMPUTE"
      buffer_size: [384, 32, 32]    
      roles: "ROLE_COMPUTE"
      bandwidth: 8
      fanouts: 0

buffer_depth: 8 # <--- [建议修改] 稍微调大一点，避免初始调试时因缓冲区太小而产生干扰
# size of flits, in bits
flit_size: 32
# lenght in mm of router to hub connection
r2h_link_length: 2.0
# lenght in mm of router to router connection
r2r_link_length: 1.0
n_virtual_channels: 3
# Routing algorithms:
routing_algorithm: XY # <--- 在1x1的网络里，路由算法不重要，XY即可
routing_table_filename: ""
dyad_threshold: 0.6
# ... (selection_strategy 等保持不变) ...
selection_strategy: RANDOM
# ------------------- [重要] 禁用所有不相关的特性 -------------------

# WIRELESS CONFIGURATION (禁用)
use_winoc: false
use_wirxsleep: false
# ------------------- SIMULATION PARAMETERS -------------------
#
clock_period_ps: 1000
reset_time: 10 # <--- [建议修改] 缩短reset时间，让我们的逻辑更快开始
simulation_time: 4000 # <--- [关键修改] 增加模拟时间，确保我们能看到完整的交互链
stats_warm_up_time: 0 # <--- [建议修改] 禁用warm up，我们想从一开始就看log
# power breakdown, nodes communication details
detailed: false
# stop after a given amount of load has been processed
max_volume_to_be_drained: 0
show_buffer_stats: false
# ... (detailed, max_volume_to_beROLE_DRAM_drained 等保持不变) ...

# Verbosity level:
verbose_mode: VERBOSE_OFF # <--- [关键修改] 设置为LOW，可以看到一些基本的网络活动日志

# Trace (可选，但推荐)
trace_mode: false # 如果需要详细的flit追踪，可以设为true，但日志会非常多
trace_filename: "debug_trace.log"

# ------------------- [重要] 禁用Noxim自带的流量注入 -------------------
# 我们现在用自己的逻辑生成流量，所以要把Noxim自带的流量注入率设为0

min_packet_size: 8
max_packet_size: 8
packet_injection_rate: 0.1 # <--- [关键修改] 设为0！
probability_of_retransmission: 0.1 # <--- [关键修改] 设为0！

# Traffic distribution:
# 将其设置为TABLE_BASED，但提供一个空文件，确保它不会产生任何随机流量。
traffic_distribution: TRAFFIC_TABLE_BASED # <--- [关键修改]
traffic_table_filename: "empty_traffic.txt" # <--- 创建一个空的txt文件