<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Hub - noxim</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">noxim</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="hub-类详细分析"><a class="header" href="#hub-类详细分析">Hub 类详细分析</a></h1>
<p>这是一个用于网络芯片(NoC)中集线器(Hub)功能实现的类定义。让我们分析其主要组成部分：</p>
<h2 id="基本结构和接口"><a class="header" href="#基本结构和接口">基本结构和接口</a></h2>
<h3 id="系统接口"><a class="header" href="#系统接口">系统接口</a></h3>
<pre><code class="language-cpp">SC_MODULE(Hub) {
    sc_in_clk clock;      // 时钟输入
    sc_in&lt;bool&gt; reset;    // 复位信号
    int local_id;         // 集线器唯一标识
}
</code></pre>
<h3 id="通信端口"><a class="header" href="#通信端口">通信端口</a></h3>
<pre><code class="language-cpp">sc_in&lt;Flit&gt;* flit_rx;    // 数据包接收端口
sc_out&lt;Flit&gt;* flit_tx;   // 数据包发送端口
sc_in&lt;bool&gt;* req_rx;     // 请求接收信号
sc_out&lt;bool&gt;* req_tx;    // 请求发送信号
</code></pre>
<h2 id="主要功能组件"><a class="header" href="#主要功能组件">主要功能组件</a></h2>
<h3 id="缓冲区管理"><a class="header" href="#缓冲区管理">缓冲区管理</a></h3>
<pre><code class="language-cpp">BufferBank* buffer_from_tile;   // 从瓦片接收数据的缓冲区
BufferBank* buffer_to_tile;     // 向瓦片发送数据的缓冲区
</code></pre>
<h3 id="令牌环控制"><a class="header" href="#令牌环控制">令牌环控制</a></h3>
<pre><code class="language-cpp">map&lt;int, sc_in&lt;int&gt;* &gt; current_token_holder;      // 当前令牌持有者
map&lt;int, sc_in&lt;int&gt;* &gt; current_token_expiration;  // 令牌过期时间
map&lt;int, sc_inout&lt;int&gt;* &gt; flag;                   // 状态标志
</code></pre>
<h2 id="构造函数实现"><a class="header" href="#构造函数实现">构造函数实现</a></h2>
<p>构造函数主要完成以下初始化工作：</p>
<ol>
<li>注册处理方法：</li>
</ol>
<pre><code class="language-cpp">if (GlobalParams::use_winoc) {
    SC_METHOD(tileToAntennaProcess);
    SC_METHOD(antennaToTileProcess);
}
</code></pre>
<ol start="2">
<li>配置基本参数：</li>
</ol>
<pre><code class="language-cpp">local_id = id;
num_ports = GlobalParams::hub_configuration[local_id].attachedNodes.size();
</code></pre>
<ol start="3">
<li>初始化通信通道：</li>
</ol>
<pre><code class="language-cpp">flit_rx = new sc_in&lt;Flit&gt;[num_ports];
flit_tx = new sc_out&lt;Flit&gt;[num_ports];
</code></pre>
<h2 id="函数"><a class="header" href="#函数">函数</a></h2>
<h3 id="int-hubrouteflit-f"><a class="header" href="#int-hubrouteflit-f"><code>int Hub::route(Flit&amp; f)</code></a></h3>
<p>这段代码实现了 Hub 类中的路由决策方法，用于确定数据包（Flit）的下一跳方向。</p>
<pre><code class="language-cpp">int Hub::route(Flit&amp; f)
{
	// 本地连接到 Hub 的节点 ID
	for (vector&lt;int&gt;::size_type i=0; i&lt; GlobalParams::hub_configuration[local_id].attachedNodes.size();i++)
	{
		// ...to a destination which is connected to the Hub
		if (GlobalParams::hub_configuration[local_id].attachedNodes[i]==f.dst_id)
		{
			return tile2Port(f.dst_id);
		}
		//到连接到目的节点并与hub相连的一个节点
		if (GlobalParams::hub_configuration[local_id].attachedNodes[i]==f.hub_relay_node)
		{
			assert(GlobalParams::winoc_dst_hops&gt;0);
			return tile2Port(f.hub_relay_node);
		}

	}
	return DIRECTION_WIRELESS;
//两者条件都不满足，表示需要无线路由
}
</code></pre>
<h3 id="hubrxpowermanager"><a class="header" href="#hubrxpowermanager"><code>Hub::rxPowerManager</code></a></h3>
<p>这是 Hub 类中的接收功率管理方法，用于控制和统计接收相关的功耗。</p>
<pre><code class="language-cpp">void Hub::rxPowerManager()
{
    // Check wheter accounting or not buffer to tile leakage
    // For each port, two poweroff condition should be checked:
    // - the buffer to tile is empty
    // - it has not been reserved
    // currently only supported without VC
    assert(GlobalParams::n_virtual_channels==1);
    for (int port=0;port&lt;num_ports;port++)
    {
        if (!buffer_to_tile[port][DEFAULT_VC].IsEmpty() ||
            antenna2tile_reservation_table.isNotReserved(port))//BUFFER非空或者端口未被预留
            power.leakageBufferToTile();
        else
            buffer_to_tile_poweroff_cycles[port]++; //端口休眠cycle++
    }
    for (unsigned int i=0;i&lt;rxChannels.size();i++)
    {
        int ch_id = rxChannels[i];
        if (!target[ch_id]-&gt;buffer_rx.IsEmpty()) //检查天线接收缓冲区是否为空
        {
            power.leakageAntennaBuffer();
        }
        else
            buffer_rx_sleep_cycles[ch_id]++;
    } 
    // Check wheter accounting antenna RX buffer
    // check if there is at least one not empty antenna RX buffer
    // To be only applied if the current hub is in RADIO_EVENT_SLEEP_ON mode
    if (power.isSleeping())
        total_sleep_cycles++;
    else // not sleeping
    {
        power.wirelessSnooping();
        power.leakageTransceiverRx();
        power.biasingRx();
    }
}
</code></pre>
<h3 id="void-hubupdaterxpower"><a class="header" href="#void-hubupdaterxpower"><code>void Hub::updateRxPower()</code></a></h3>
<pre><code class="language-cpp">void Hub::updateRxPower()
{
   // 1. 检查是否使用功率管理器
   if (GlobalParams::use_powermanager)
       // 2. 如果使用，调用 rxPowerManager 进行详细的功率管理
       rxPowerManager();
   else
   {
       // 3. 如果不使用，执行基本的功率计算
       power.wirelessSnooping();       // 无线监听功耗
       power.leakageTransceiverRx();   // 接收器泄漏功耗
       power.biasingRx();              // 接收器偏置功耗

       // 4. 遍历所有接收通道和虚拟通道，计算天线缓冲区泄漏功耗
       for (unsigned int i=0; i&lt;rxChannels.size(); i++)
           for (int vc=0; vc&lt;GlobalParams::n_virtual_channels; vc++)
               power.leakageAntennaBuffer();

       // 5. 遍历所有端口和虚拟通道，计算 Tile 缓冲区泄漏功耗
       for (int i = 0; i &lt; num_ports; i++)
           for (int vc=0; vc&lt;GlobalParams::n_virtual_channels; vc++)
               power.leakageBufferToTile();
   }
}
</code></pre>
<h3 id="void-hubtxpowermanager"><a class="header" href="#void-hubtxpowermanager"><code>void Hub::txPowerManager()</code></a></h3>
<pre><code class="language-cpp">void Hub::txPowerManager()
{
    // 1. 遍历所有发送通道
    for (unsigned int i = 0; i &lt; txChannels.size(); i++)
    {
        // 2. 检查通道是否为空闲或未被预留
        if (!init[i]-&gt;buffer_tx.IsEmpty() ||
            tile2antenna_reservation_table.isNotReserved(i))
        {
            // 3. 如果通道活动，则计算天线缓冲区泄漏功耗
            power.leakageAntennaBuffer();

            // 4. 检查 Hub 是否处于休眠状态
            if (power.isSleeping())
            {
                // 5. 如果处于休眠状态，则增加模拟发送关闭周期计数
                analogtxoff_cycles[i]++;
            }
            else
            {
                // 6. 如果未处于休眠状态，则计算发送器泄漏功耗和偏置功耗
                power.leakageTransceiverTx();
                power.biasingTx();
            }
        }
        else
        {
            // 7. 如果通道空闲且未被预留，则增加各种关闭周期计数
            abtxoff_cycles[i]++;        // 天线缓冲区关闭周期
            analogtxoff_cycles[i]++;    // 模拟发送关闭周期
            total_ttxoff_cycles++;       // 总发送关闭周期
        }
    }
}
</code></pre>
<h3 id="void-hubupdatetxpower"><a class="header" href="#void-hubupdatetxpower"><code>void Hub::updateTxPower()</code></a></h3>
<pre><code class="language-cpp">void Hub::updateTxPower()
{
    // 1. 检查是否使用功率管理器
    if (GlobalParams::use_powermanager)
        // 2. 如果使用，调用 txPowerManager 进行详细的功率管理
        txPowerManager();
    else
    {
        // 3. 如果不使用，则执行基本的功率计算
        for (unsigned int i=0; i&lt;txChannels.size(); i++)
            for (int vc=0; vc&lt;GlobalParams::n_virtual_channels; vc++)
                power.leakageAntennaBuffer();  // 计算天线缓冲区泄漏功耗

        power.leakageTransceiverTx();      // 计算发送器泄漏功耗
        power.biasingTx();                 // 计算发送器偏置功耗
    }

    // 4. 强制执行的功率计算
    power.leakageLinkRouter2Hub();         // 计算 Router 到 Hub 链路的泄漏功耗
    for (int i = 0; i &lt; num_ports; i++)
        for (int vc=0; vc&lt;GlobalParams::n_virtual_channels; vc++)
            power.leakageBufferFromTile();   // 计算 Tile 到 Hub 缓冲区的泄漏功耗
}
</code></pre>
<h3 id="hubtxradioprocesstokenpacket"><a class="header" href="#hubtxradioprocesstokenpacket">Hub::txRadioProcessTokenPacket</a></h3>
<p>这是 Hub 类中处理令牌包传输的方法。让我们详细分析其实现和功能。</p>
<h4 id="核心功能"><a class="header" href="#核心功能">核心功能</a></h4>
<h4 id="1-状态检查"><a class="header" href="#1-状态检查">1. 状态检查</a></h4>
<pre><code class="language-cpp">int current_holder = current_token_holder[channel]-&gt;read();
int current_channel_flag = flag[channel]-&gt;read();
</code></pre>
<ul>
<li>获取当前令牌持有者</li>
<li>获取当前通道标志状态</li>
</ul>
<h4 id="2-处理逻辑"><a class="header" href="#2-处理逻辑">2. 处理逻辑</a></h4>
<p>当本地节点持有令牌且通道未释放时，进行以下处理：</p>
<h5 id="发送缓冲区非空时"><a class="header" href="#发送缓冲区非空时">发送缓冲区非空时：</a></h5>
<pre><code class="language-cpp">if (!init[channel]-&gt;buffer_tx.IsEmpty()) {
    Flit flit = init[channel]-&gt;buffer_tx.Front();
    init[channel]-&gt;start_request_event.notify();
}
</code></pre>
<ul>
<li>获取待发送的数据包</li>
<li>触发传输请求事件</li>
</ul>
<h5 id="发送缓冲区为空时"><a class="header" href="#发送缓冲区为空时">发送缓冲区为空时：</a></h5>
<ul>
<li>如果没有正在进行的传输，释放令牌</li>
<li>如果有传输正在进行，保持令牌</li>
</ul>
<pre><code class="language-cpp">void Hub::txRadioProcessTokenPacket(int channel)
{
    int current_holder = current_token_holder[channel]-&gt;read();//获取当前令牌持有者
    int current_channel_flag =flag[channel]-&gt;read();//获取当前通道标志状态
    if ( current_holder == local_id &amp;&amp; current_channel_flag !=RELEASE_CHANNEL) //本地节点持有令牌且通道未释放
    {
        if (!init[channel]-&gt;buffer_tx.IsEmpty())//发送缓冲区非空时
        {
            Flit flit = init[channel]-&gt;buffer_tx.Front();//获取待发送的数据包
            // TODO: check whether it would make sense to use transmission_in_progress to
            // avoid multiple notify()
            LOG &lt;&lt; "*** [Ch"&lt;&lt;channel&lt;&lt;"] Requesting transmission event of flit " &lt;&lt; flit &lt;&lt; endl;
            init[channel]-&gt;start_request_event.notify(); //触发传输请求事件
        }
        else
        {
            if (!transmission_in_progress.at(channel)) //没有传输正在进行
            {
                LOG &lt;&lt; "*** [Ch"&lt;&lt;channel&lt;&lt;"] Buffer_tx empty and no trasmission in progress, releasing token" &lt;&lt; endl;
                flag[channel]-&gt;write(RELEASE_CHANNEL); //标记通道为释放状态
            }
            else
                LOG &lt;&lt; "*** [Ch"&lt;&lt;channel&lt;&lt;"] Buffer_tx empty, but trasmission in progress, holding token" &lt;&lt; endl;
        }
    }
}
</code></pre>
<h3 id="void-hubtxradioprocesstokenhold"><a class="header" href="#void-hubtxradioprocesstokenhold"><code>void Hub::txRadioProcessTokenHold</code></a></h3>
<pre><code class="language-cpp">void Hub::txRadioProcessTokenHold(int channel)
{
    // 1. 如果通道被释放，则重新持有
    if (flag[channel]-&gt;read() == RELEASE_CHANNEL)
        flag[channel]-&gt;write(HOLD_CHANNEL);

    // 2. 检查当前 Hub 是否为令牌持有者
    if (current_token_holder[channel]-&gt;read() == local_id)
    {
        // 3. 检查发送缓冲区是否为空
        if (!init[channel]-&gt;buffer_tx.IsEmpty())
        {
            // 4. 检查令牌过期时间是否足够发送数据包
            if (current_token_expiration[channel]-&gt;read() &lt; flit_transmission_cycles[channel])
            {
                // 5. 如果令牌时间不足，则不发送数据包
                //LOG &lt;&lt; "TOKEN_HOLD policy: Not enough token expiration time for sending channel " &lt;&lt; channel &lt;&lt; endl;
            }
            else
            {
                // 6. 如果令牌时间足够，则持有通道并触发传输事件
                flag[channel]-&gt;write(HOLD_CHANNEL);
                LOG &lt;&lt; "*** [Ch" &lt;&lt; channel &lt;&lt; "] Starting transmission event" &lt;&lt; endl;
                init[channel]-&gt;start_request_event.notify();
            }
        }
        else
        {
            // 7. 如果发送缓冲区为空，则继续持有令牌
            //LOG &lt;&lt; "TOKEN_HOLD policy: nothing to transmit, holding token for channel " &lt;&lt; channel &lt;&lt; endl;
        }
    }
}
</code></pre>
<h3 id="void-hubtxradioprocesstokenmaxhold"><a class="header" href="#void-hubtxradioprocesstokenmaxhold"><code>void Hub::txRadioProcessTokenMaxHold</code></a></h3>
<pre><code class="language-cpp">void Hub::txRadioProcessTokenMaxHold(int channel)
{
    // 1. 如果通道被释放，则重新持有
    if (flag[channel]-&gt;read() == RELEASE_CHANNEL)
        flag[channel]-&gt;write(HOLD_CHANNEL);

    // 2. 检查当前 Hub 是否为令牌持有者
    if (current_token_holder[channel]-&gt;read() == local_id)
    {
        // 3. 检查发送缓冲区是否为空
        if (!init[channel]-&gt;buffer_tx.IsEmpty())
        {
            // 4. 检查令牌过期时间是否足够发送数据包
            if (current_token_expiration[channel]-&gt;read() &lt; flit_transmission_cycles[channel])
            {
                // 5. 如果令牌时间不足，则释放令牌
                //LOG &lt;&lt; "TOKEN_MAX_HOLD: Not enough token expiration time, releasing token for channel " &lt;&lt; channel &lt;&lt; endl;
                flag[channel]-&gt;write(RELEASE_CHANNEL);
            }
            else
            {
                // 6. 如果令牌时间足够，则持有通道并触发传输事件
                flag[channel]-&gt;write(HOLD_CHANNEL);
                LOG &lt;&lt; "Starting transmission on channel " &lt;&lt; channel &lt;&lt; endl;
                init[channel]-&gt;start_request_event.notify();
            }
        }
        else
        {
            // 7. 如果发送缓冲区为空，则释放令牌
            //LOG &lt;&lt; "TOKEN_MAX_HOLD: Buffer_tx empty, releasing token for channel " &lt;&lt; channel &lt;&lt; endl;
            flag[channel]-&gt;write(RELEASE_CHANNEL);
        }
    }
}
</code></pre>
<pre><code class="language-cpp">void Hub::antennaToTileProcess()
{
    // 1. 复位处理: 如果复位信号有效，则初始化输出端口
    if (reset.read())
    {
        for (int i = 0; i &lt; num_ports; i++)
        {
            req_tx[i]-&gt;write(0);		// 关闭请求信号
            current_level_tx[i] = 0;	// 重置当前发送电平
        }
        return;
    }
    // 重要: 请勿移动此行!
    // rxPowerManager 必须在从缓冲区移除 Flit 之前执行其检查
    updateRxPower();

    /***********************************************************************************
      数据从天线流向 Tile 包含 3 个不同的步骤:

      1) 从无线信道接收的数据存储到特定的 buffer_rx (如果可能)
      2) 在 buffer_rx 中找到的数据移动到 buffer_to_tile
      3) 在 buffer_to_tile 中找到的数据移动到 signal_tx

      从实现的角度来看, 它们以 3-2-1 的顺序执行, 以模拟一种流水线序列
     ***********************************************************************************/

    //////////////////////////////////////////////////////////////////////////////////////
    // 将 Flit 从 buffer_to_tile 移动到相应的 signal_tx
    // 无需路由: 每个端口都与一个预定义的 Tile 相关联
    for (int i = 0; i &lt; num_ports; i++)
    {
        // TODO: 检查阻塞通道 (例如阻塞单个信号?)
        for (int k = 0; k &lt; GlobalParams::n_virtual_channels; k++)
        {
            int vc = (start_from_vc[i] + k) % (GlobalParams::n_virtual_channels);

            if (!buffer_to_tile[i][vc].IsEmpty())
            {
                Flit flit = buffer_to_tile[i][vc].Front();

                LOG &lt;&lt; "Flit " &lt;&lt; flit &lt;&lt; " found on buffer_to_tile[" &lt;&lt; i &lt;&lt; "][" &lt;&lt; vc &lt;&lt; "] " &lt;&lt; endl;
                if (current_level_tx[i] == ack_tx[i].read() &amp;&amp;
                    buffer_full_status_tx[i].read().mask[vc] == false)
                {
                    LOG &lt;&lt; "Flit " &lt;&lt; flit &lt;&lt; " moved from buffer_to_tile[" &lt;&lt; i &lt;&lt; "][" &lt;&lt; vc &lt;&lt; "] to signal flit_tx[" &lt;&lt; i &lt;&lt; "] " &lt;&lt; endl;

                    flit_tx[i].write(flit);					// 将 Flit 写入输出端口
                    current_level_tx[i] = 1 - current_level_tx[i];	// 翻转当前电平
                    req_tx[i].write(current_level_tx[i]);		// 写入请求信号

                    buffer_to_tile[i][vc].Pop();			// 从 buffer_to_tile 移除 Flit
                    power.bufferToTilePop();				// 更新 bufferToTile 弹出操作的功耗统计
                    power.r2hLink();					// 更新 Router 到 Hub 链路的功耗统计
                    break; // 端口 Flit 已发送, 跳过剩余 VC
                }
                else
                {
                    LOG &lt;&lt; "Flit " &lt;&lt; flit &lt;&lt; " cannot move from buffer_to_tile[" &lt;&lt; i &lt;&lt; "][" &lt;&lt; vc &lt;&lt; "] to signal flit_tx[" &lt;&lt; i &lt;&lt; "] " &lt;&lt; endl;
                }
            } // if buffer not empty
        }
        start_from_vc[i] = (start_from_vc[i] + 1) % GlobalParams::n_virtual_channels;
    }

    /////////////////////////////////////////////////////////////////////////////////
    // 将 Flit 从天线 buffer_rx 移动到相应的 buffer_to_tile
    //
    // 两个不同的阶段:
    // 1) 存储有关传入 Flit 的路由决策 (例如, 到哪个输出端口)
    // 2) 移动 Flit 并从天线 buffer_rx 中移除

    for (unsigned int i = 0; i &lt; rxChannels.size(); i++)
    {
        int channel = rxChannels[i];

        if (!(target[channel]-&gt;buffer_rx.IsEmpty()))
        {
            Flit received_flit = target[channel]-&gt;buffer_rx.Front();
            power.antennaBufferFront();

            // 检查天线 buffer_rx 并进行适当的预留
            if (received_flit.flit_type == FLIT_TYPE_HEAD)
            {
                int dst_port;

                if (received_flit.hub_relay_node != NOT_VALID)
                    dst_port = tile2Port(received_flit.hub_relay_node);
                else
                    dst_port = tile2Port(received_flit.dst_id);

                TReservation r;
                r.input = channel;
                r.vc = received_flit.vc_id;

                LOG &lt;&lt; " Checking reservation availability of output port " &lt;&lt; dst_port &lt;&lt; " by channel " &lt;&lt; channel &lt;&lt; " for flit " &lt;&lt; received_flit &lt;&lt; endl;

                int rt_status = antenna2tile_reservation_table.checkReservation(r, dst_port);

                if (rt_status == RT_AVAILABLE)
                {
                    LOG &lt;&lt; "Reserving output port " &lt;&lt; dst_port &lt;&lt; " by channel " &lt;&lt; channel &lt;&lt; " for flit " &lt;&lt; received_flit &lt;&lt; endl;
                    antenna2tile_reservation_table.reserve(r, dst_port);

                    // 使用无线网络进行的通信次数, 也包括部分有线路径
                    wireless_communications_counter++;
                }
                else if (rt_status == RT_ALREADY_SAME)
                {
                    LOG &lt;&lt; " RT_ALREADY_SAME reserved direction " &lt;&lt; dst_port &lt;&lt; " for flit " &lt;&lt; received_flit &lt;&lt; endl;
                }
                else if (rt_status == RT_OUTVC_BUSY)
                {
                    LOG &lt;&lt; " RT_OUTVC_BUSY reservation direction " &lt;&lt; dst_port &lt;&lt; " for flit " &lt;&lt; received_flit &lt;&lt; endl;
                }
                else assert(false); // 此处没有有意义的状态
            }
        }
    }
    // 转发
    for (unsigned int i = 0; i &lt; rxChannels.size(); i++)
    {
        int channel = rxChannels[i];
        vector&lt;pair&lt;int, int&gt; &gt; reservations = antenna2tile_reservation_table.getReservations(channel);

        if (reservations.size() != 0)
        {
            int rnd_idx = rand() % reservations.size();

            int port = reservations[rnd_idx].first;
            int vc = reservations[rnd_idx].second;

            if (!(target[channel]-&gt;buffer_rx.IsEmpty()))
            {
                Flit received_flit = target[channel]-&gt;buffer_rx.Front();
                power.antennaBufferFront();

                if (!buffer_to_tile[port][vc].IsFull())
                {
                    target[channel]-&gt;buffer_rx.Pop();		// 从天线 buffer_rx 移除 Flit
                    power.antennaBufferPop();			// 更新天线缓冲区弹出操作的功耗统计
                    LOG &lt;&lt; "*** [Ch" &lt;&lt; channel &lt;&lt; "] Moving flit  " &lt;&lt; received_flit &lt;&lt; " from buffer_rx to buffer_to_tile[" &lt;&lt; port &lt;&lt; "][" &lt;&lt; vc &lt;&lt; "]" &lt;&lt; endl;

                    buffer_to_tile[port][vc].Push(received_flit);	// 将 Flit 推送到 buffer_to_tile
                    power.bufferToTilePush();			// 更新 bufferToTile 推送操作的功耗统计

                    if (received_flit.flit_type == FLIT_TYPE_TAIL)
                    {
                        LOG &lt;&lt; "Releasing reservation for output port " &lt;&lt; port &lt;&lt; ", flit " &lt;&lt; received_flit &lt;&lt; endl;
                        TReservation r;
                        r.input = channel;
                        r.vc = vc;
                        antenna2tile_reservation_table.release(r, port);
                    }
                }
                else
                    LOG &lt;&lt; "Full buffer_to_tile[" &lt;&lt; port &lt;&lt; "][" &lt;&lt; vc &lt;&lt; "], cannot store " &lt;&lt; received_flit &lt;&lt; endl;
            }
            else
            {
                // 应该没问题
                /*
                LOG &lt;&lt; "WARNING: empty target["&lt;&lt;channel&lt;&lt;"] buffer_rx, but reservation still present, if correct, remove assertion below " &lt;&lt; endl;
                assert(false);
                */
            }
        }
    }
}
</code></pre>
<h3 id="void-hubtiletoantennaprocess"><a class="header" href="#void-hubtiletoantennaprocess"><code>void Hub::tileToAntennaProcess()</code></a></h3>
<pre><code class="language-cpp">void Hub::tileToAntennaProcess()
{
    // double cycle = sc_time_stamp().to_double() / GlobalParams::clock_period_ps;
    // if (cycle &gt; 0 &amp;&amp; cycle &lt; 58428)
    // {
    //     if (local_id == 1)
    //     {
    //         cout &lt;&lt; "CYCLES " &lt;&lt; cycle &lt;&lt; endl;
    //         for (int j = 0; j &lt; num_ports; j++)
    //     	buffer_from_tile[j].Print();;
    //         init[0]-&gt;buffer_tx.Print();
    //         cout &lt;&lt; endl;
    //     }
    // }

    // 1. 复位处理：如果复位信号有效，则初始化发送通道
    if (reset.read())
    {
        for (unsigned int i = 0; i &lt; txChannels.size(); i++)
        {
            int channel = txChannels[i];
            flag[channel]-&gt;write(HOLD_CHANNEL); // 设置通道为 HOLD 状态
        }

        TBufferFullStatus bfs;
        for (int i = 0; i &lt; num_ports; i++)
        {
            ack_rx[i]-&gt;write(0);				   // 关闭确认信号
            buffer_full_status_rx[i].write(bfs);   // 初始化缓冲区满状态
            current_level_rx[i] = 0;			   // 重置当前接收电平
        }
        return;
    }

    // 2. 令牌环 MAC 策略处理：根据配置的 MAC 策略处理每个发送通道
    for (unsigned int i = 0; i &lt; txChannels.size(); i++)
    {
        int channel = txChannels[i];

        string macPolicy = token_ring-&gt;getPolicy(channel).first;

        if (macPolicy == TOKEN_PACKET)
            txRadioProcessTokenPacket(channel); // TOKEN_PACKET 策略
        else if (macPolicy == TOKEN_HOLD)
            txRadioProcessTokenHold(channel);   // TOKEN_HOLD 策略
        else if (macPolicy == TOKEN_MAX_HOLD)
            txRadioProcessTokenMaxHold(channel); // TOKEN_MAX_HOLD 策略
        else
            assert(false); // 未知的 MAC 策略
    }

    int last_reserved = NOT_VALID;

    // 用于存储路由决策
    int *r_from_tile[num_ports];
    for (int i = 0; i &lt; num_ports; i++)
        r_from_tile[i] = new int[GlobalParams::n_virtual_channels];

    // 3. 预留阶段：为从 Tile 到天线的传输进行通道预留
    for (int j = 0; j &lt; num_ports; j++)
    {
        int i = (start_from_port + j) % (num_ports); // 循环遍历端口

        for (int k = 0; k &lt; GlobalParams::n_virtual_channels; k++)
        {
            int vc = (start_from_vc[i] + k) % (GlobalParams::n_virtual_channels);

            // 4. 检查 buffer_from_tile 是否为空
            if (!buffer_from_tile[i][vc].IsEmpty())
            {
                LOG &lt;&lt; "Reservation: buffer_from_tile[" &lt;&lt; i &lt;&lt; "][" &lt;&lt; vc &lt;&lt; "] not empty " &lt;&lt; endl;

                Flit flit = buffer_from_tile[i][vc].Front();

                assert(flit.vc_id == vc);

                power.bufferFromTileFront();		// 更新 bufferFromTile 前端操作的功耗统计
                r_from_tile[i][vc] = route(flit); // 进行路由决策

                // 5. 如果是 HEAD Flit，则进行通道预留
                if (flit.flit_type == FLIT_TYPE_HEAD)
                {
                    TReservation r;
                    r.input = i;
                    r.vc = vc;

                    assert(r_from_tile[i][vc] == DIRECTION_WIRELESS);
                    int channel;

                    // 确定目标通道
                    if (flit.hub_relay_node == NOT_VALID)
                        channel = selectChannel(local_id, tile2Hub(flit.dst_id));
                    else
                        channel = selectChannel(local_id, tile2Hub(flit.hub_relay_node));

                    assert(channel != NOT_VALID &amp;&amp; "hubs are not connected by any channel");

                    LOG &lt;&lt; "Checking reservation availability of Channel " &lt;&lt; channel &lt;&lt; " by Hub port[" &lt;&lt; i &lt;&lt; "][" &lt;&lt; vc &lt;&lt; "] for flit " &lt;&lt; flit &lt;&lt; endl;

                    int rt_status = tile2antenna_reservation_table.checkReservation(r, channel);

                    if (rt_status == RT_AVAILABLE)
                    {
                        LOG &lt;&lt; "Reservation of channel " &lt;&lt; channel &lt;&lt; " from Hub port[" &lt;&lt; i &lt;&lt; "][" &lt;&lt; vc &lt;&lt; "] by flit " &lt;&lt; flit &lt;&lt; endl;
                        tile2antenna_reservation_table.reserve(r, channel); // 预留通道
                    }
                    else if (rt_status == RT_ALREADY_SAME)
                    {
                        LOG &lt;&lt; "RT_ALREADY_SAME reserved channel " &lt;&lt; channel &lt;&lt; " for flit " &lt;&lt; flit &lt;&lt; endl;
                    }
                    else if (rt_status == RT_OUTVC_BUSY)
                    {
                        LOG &lt;&lt; "RT_OUTVC_BUSY reservation for channel " &lt;&lt; channel &lt;&lt; " for flit " &lt;&lt; flit &lt;&lt; endl;
                    }
                    else if (rt_status == RT_ALREADY_OTHER_OUT)
                    {
                        LOG &lt;&lt; "RT_ALREADY_OTHER_OUT a channel different from " &lt;&lt; channel &lt;&lt; " already reserved by Hub port[" &lt;&lt; i &lt;&lt; "][" &lt;&lt; vc &lt;&lt; "]" &lt;&lt; endl;
                    }
                    else
                        assert(false); // 此处没有有意义的状态
                }
            }
        }
        start_from_vc[i] = (start_from_vc[i] + 1) % GlobalParams::n_virtual_channels;
    } // for num_ports

    if (last_reserved != NOT_VALID)
        start_from_port = (last_reserved + 1) % num_ports;

    // 6. 转发阶段：将 Flit 从 buffer_from_tile 转发到天线 buffer_tx
    for (int i = 0; i &lt; num_ports; i++)
    {
        vector&lt;pair&lt;int, int&gt; &gt; reservations = tile2antenna_reservation_table.getReservations(i);

        if (reservations.size() != 0)
        {
            int rnd_idx = rand() % reservations.size();

            int o = reservations[rnd_idx].first;
            int vc = reservations[rnd_idx].second;

            // 7. 检查 buffer_from_tile 是否为空
            if (!buffer_from_tile[i][vc].IsEmpty())
            {
                Flit flit = buffer_from_tile[i][vc].Front();
                // powerFront already accounted in 1st phase

                assert(r_from_tile[i][vc] == DIRECTION_WIRELESS);

                int channel = o;

                if (channel != NOT_RESERVED)
                {
                    // 8. 检查天线 buffer_tx 是否已满
                    if (!(init[channel]-&gt;buffer_tx.IsFull()))
                    {
                        buffer_from_tile[i][vc].Pop();	  // 从 buffer_from_tile 移除 Flit
                        power.bufferFromTilePop();		  // 更新 bufferFromTile 弹出操作的功耗统计
                        init[channel]-&gt;buffer_tx.Push(flit); // 将 Flit 推送到天线 buffer_tx
                        power.antennaBufferPush();		  // 更新天线缓冲区推送操作的功耗统计
                        if (flit.flit_type == FLIT_TYPE_TAIL)
                        {
                            TReservation r;
                            r.input = i;
                            r.vc = vc;
                            tile2antenna_reservation_table.release(r, channel); // 释放通道预留
                        }

                        LOG &lt;&lt; "Flit " &lt;&lt; flit &lt;&lt; " moved from buffer_from_tile[" &lt;&lt; i &lt;&lt; "][" &lt;&lt; vc &lt;&lt; "]  to buffer_tx[" &lt;&lt; channel &lt;&lt; "] " &lt;&lt; endl;
                    }
                    else
                    {
                        LOG &lt;&lt; "Buffer Full: Cannot move flit " &lt;&lt; flit &lt;&lt; " from buffer_from_tile[" &lt;&lt; i &lt;&lt; "] to buffer_tx[" &lt;&lt; channel &lt;&lt; "] " &lt;&lt; endl;
                        //init[channel]-&gt;buffer_tx.Print();
                    }
                }
                else
                {
                    LOG &lt;&lt; "Forwarding: No channel reserved for input port [" &lt;&lt; i &lt;&lt; "][" &lt;&lt; vc &lt;&lt; "], flit " &lt;&lt; flit &lt;&lt; endl;
                }
            }

        } // for all the ports
    }

    // 9. 从 flit_rx 信号读取 Flit 并存储到 buffer_from_tile
    for (int i = 0; i &lt; num_ports; i++)
    {
        // 10. 检查是否有新的 Flit 到达
        if (req_rx[i]-&gt;read() == 1 - current_level_rx[i])
        {
            Flit received_flit = flit_rx[i]-&gt;read();
            int vc = received_flit.vc_id;
            LOG &lt;&lt; "Reading " &lt;&lt; received_flit &lt;&lt; " from signal flit_rx[" &lt;&lt; i &lt;&lt; "]" &lt;&lt; endl;

            /*
            if (!buffer_from_tile[i][vc].deadlockFree())
            {
            LOG &lt;&lt; " deadlock on buffer " &lt;&lt; i &lt;&lt; endl;
            buffer_from_tile[i][vc].Print();
            }
            */

            // 11. 检查 buffer_from_tile 是否已满
            if (!buffer_from_tile[i][vc].IsFull())
            {
                LOG &lt;&lt; "Storing " &lt;&lt; received_flit &lt;&lt; " on buffer_from_tile[" &lt;&lt; i &lt;&lt; "][" &lt;&lt; vc &lt;&lt; "]" &lt;&lt; endl;

                buffer_from_tile[i][vc].Push(received_flit); // 将 Flit 推送到 buffer_from_tile
                power.bufferFromTilePush();				   // 更新 bufferFromTile 推送操作的功耗统计

                current_level_rx[i] = 1 - current_level_rx[i]; // 翻转当前接收电平
            }
            else
            {
                LOG &lt;&lt; "Buffer Full: Cannot store " &lt;&lt; received_flit &lt;&lt; " on buffer_from_tile[" &lt;&lt; i &lt;&lt; "][" &lt;&lt; vc &lt;&lt; "]" &lt;&lt; endl;
                //buffer_from_tile[i][TODO_VC].Print();
            }
        }
        ack_rx[i]-&gt;write(current_level_rx[i]); // 写入确认信号

        // 12. 更新 VC 的掩码以防止数据进入已满的缓冲区
        TBufferFullStatus bfs;
        for (int vc = 0; vc &lt; GlobalParams::n_virtual_channels; vc++)
            bfs.mask[vc] = buffer_from_tile[i][vc].IsFull();
        buffer_full_status_rx[i].write(bfs);
    }

    // 重要: 请勿移动此行!
    // txPowerManager 假设所有 Flit 缓冲区写入操作已完成
    updateTxPower();
}
</code></pre>
<p><strong>关键步骤：</strong></p>
<ol>
<li><strong>复位处理</strong>：初始化发送通道状态。</li>
<li><strong>MAC 策略处理</strong>：根据配置的 MAC 策略处理每个发送通道（TOKEN_PACKET, TOKEN_HOLD, TOKEN_MAX_HOLD）。</li>
<li><strong>预留阶段</strong>：为从 Tile 到天线的传输进行通道预留。</li>
<li><strong>检查 buffer_from_tile</strong>：判断缓冲区是否为空。</li>
<li><strong>HEAD Flit 处理</strong>：如果是 HEAD Flit，则进行通道预留。</li>
<li><strong>转发阶段</strong>：将 Flit 从 buffer_from_tile 转发到天线 buffer_tx。</li>
<li><strong>检查 buffer_from_tile</strong>：判断缓冲区是否为空。</li>
<li><strong>检查天线 buffer_tx</strong>：判断天线缓冲区是否已满。</li>
<li><strong>从 flit_rx 读取 Flit</strong>：从 flit_rx 信号读取 Flit 并存储到 buffer_from_tile。</li>
<li><strong>检查是否有新 Flit</strong>：判断是否有新的 Flit 到达。</li>
<li><strong>检查 buffer_from_tile</strong>：判断缓冲区是否已满。</li>
<li><strong>更新 VC 掩码</strong>：更新 VC 的掩码以防止数据进入已满的缓冲区。</li>
<li><strong>更新发送功率</strong>：更新发送功率统计。</li>
</ol>
<h3 id="hubselectchannel"><a class="header" href="#hubselectchannel"><code>Hub::selectChannel()</code></a></h3>
<pre><code class="language-cpp">int Hub::selectChannel(int src_hub, int dst_hub) const
{
    // 1. 获取源 Hub 的发送通道和目标 Hub 的接收通道
    vector&lt;int&gt; &amp; first = GlobalParams::hub_configuration[src_hub].txChannels;
    vector&lt;int&gt; &amp; second = GlobalParams::hub_configuration[dst_hub].rxChannels;

    // 2. 找到两个 Hub 之间共有的通道（交集）
    vector&lt;int&gt; intersection;

    for (unsigned int i = 0; i &lt; first.size(); i++)
    {
        for (unsigned int j = 0; j &lt; second.size(); j++)
        {
            if (first[i] == second[j])
                intersection.push_back(first[i]); // 将共有通道添加到交集向量
        }
    }

    // 3. 如果没有找到共有通道，则返回 NOT_VALID
    if (intersection.size() == 0)
        return NOT_VALID;

    // 4. 根据全局参数选择通道
    if (GlobalParams::channel_selection == CHSEL_RANDOM)
        // 5. 如果选择随机通道，则从交集中随机选择一个通道
        return intersection[rand() % intersection.size()];
    else if (GlobalParams::channel_selection == CHSEL_FIRST_FREE)
    {
        // 6. 如果选择第一个空闲通道，则从交集中查找第一个空闲通道
        int start_channel = rand() % intersection.size(); // 随机选择起始通道
        int k;

        for (vector&lt;int&gt;::size_type i = 0; i &lt; intersection.size(); i++)
        {
            k = (start_channel + i) % intersection.size(); // 循环遍历交集

            // 7. 检查通道是否空闲
            if (!transmission_in_progress.at(intersection[k]))
            {
                cout &lt;&lt; "Found free channel " &lt;&lt; intersection[k] &lt;&lt; " on (src,dest) (" &lt;&lt; src_hub &lt;&lt; "," &lt;&lt; dst_hub &lt;&lt; ") " &lt;&lt; endl;
                return intersection[k]; // 找到空闲通道，返回
            }
        }
        // 8. 如果所有通道都忙，则应用随机选择
        cout &lt;&lt; "All channel busy, applying random selection " &lt;&lt; endl;
        return intersection[rand() % intersection.size()];
    }

    return NOT_VALID; // 未知的通道选择策略
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="Channel.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="TokenRing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="Channel.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="TokenRing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
